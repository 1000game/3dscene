<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kingdom Centre 3D Visualization</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* Floating Labels */
        .annotation {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transform: translate(-50%, -100%); /* Center above the point */
            width: 200px;
        }
        .annotation h3 {
            margin: 0 0 5px 0;
            font-size: 16px;
            font-weight: 600;
            color: #4db8ff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .annotation p {
            margin: 0;
            line-height: 1.4;
            font-size: 12px;
            color: #eee;
        }
        
        /* Loading overlay */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; color: white; display: flex; 
            justify-content: center; align-items: center; font-size: 1.5rem;
            z-index: 999; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loader">Loading 3D Scene...</div>
    <div id="canvas-container"></div>

    <div id="info-bridge" class="annotation">
        <h3>Sky Bridge</h3>
        <p>A 65m long steel structure weighing 300 tons, sitting 300m above the city.</p>
    </div>
    <div id="info-base" class="annotation">
        <h3>Podium & Entrance</h3>
        <p>Contains the shopping mall and hotel entrance with luxury amenities.</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        // --- Configuration ---
        const SCENE_CONFIG = {
            skyColor: 0x87CEEB,
            groundColor: 0x222222,
            towerHeight: 120,
            towerWidth: 30,
            glassColor: 0x88ccee,
        };

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xaaccff);
        scene.fog = new THREE.FogExp2(0xaaccff, 0.0015);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(150, 80, 150);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.02; // Prevent going below ground
        controls.minDistance = 50;
        controls.maxDistance = 400;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(100, 200, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        const d = 150;
        sunLight.shadow.camera.left = -d;
        sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d;
        sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.bias = -0.0001;
        scene.add(sunLight);

        // --- Skysphere with Clouds ---
        // Generating a procedural cloud texture
        function createCloudTexture() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Sky Gradient
            const grad = ctx.createLinearGradient(0, 0, 0, size);
            grad.addColorStop(0, "#1E90FF");
            grad.addColorStop(1, "#87CEFA");
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, size, size);

            // Simple noise for clouds
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            for(let i=0; i<400; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size * 0.6 + size * 0.2; // Keep clouds mostly in middle band
                const r = Math.random() * 30 + 10;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }

        const skyGeo = new THREE.SphereGeometry(600, 32, 32);
        const skyMat = new THREE.MeshBasicMaterial({ 
            map: createCloudTexture(), 
            side: THREE.BackSide, 
            fog: false 
        });
        const skySphere = new THREE.Mesh(skyGeo, skyMat);
        scene.add(skySphere);

        // --- Materials ---
        
        // Procedural Window Map (Grid)
        function createWindowMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#444'; // Frame
            ctx.fillRect(0,0,512,512);
            ctx.fillStyle = '#fff'; // Glass (smoothness)
            const rows = 10; const cols = 5;
            const gap = 2;
            const w = 512/cols; const h = 512/rows;
            for(let y=0; y<rows; y++) {
                for(let x=0; x<cols; x++) {
                    ctx.fillRect(x*w+gap, y*h+gap, w-gap*2, h-gap*2);
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }
        
        const windowRoughness = createWindowMap();
        windowRoughness.repeat.set(4, 10);

        // High Quality Glass Material
        const glassMaterial = new THREE.MeshPhysicalMaterial({
            color: SCENE_CONFIG.glassColor,
            metalness: 0.9,
            roughness: 0.1,
            roughnessMap: windowRoughness,
            transmission: 0.1,
            transparent: true,
            opacity: 0.9,
            reflectivity: 1,
            clearcoat: 1.0,
            clearcoatRoughness: 0.0,
            side: THREE.DoubleSide
        });

        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.4, metalness: 0.5 });
        const concreteMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.9 });

        // --- Building Generation ---

        function createKingdomTower() {
            const tower = new THREE.Group();
            
            // 1. Main Body (Elliptical Cylinder)
            const height = SCENE_CONFIG.towerHeight;
            const width = SCENE_CONFIG.towerWidth;
            const depth = width * 0.4;
            const curveStart = height * 0.75;
            
            // To create the cutout shape, we'll use a Shape extruded along a path,
            // or simpler: Compose it of the base body and the two "wings".
            
            // Base Body
            const bodyH = curveStart;
            const bodyGeo = new THREE.CylinderGeometry(width*0.5, width*0.55, bodyH, 64);
            bodyGeo.scale(1, 1, 0.4); // Flatten it
            const body = new THREE.Mesh(bodyGeo, glassMaterial);
            body.position.y = bodyH / 2;
            body.castShadow = true;
            body.receiveShadow = true;
            
            // Fix UVs for window texture tiling
            const uv = bodyGeo.attributes.uv;
            for(let i=0; i<uv.count; i++) {
                uv.setY(i, uv.getY(i) * 5);
                uv.setX(i, uv.getX(i) * 3);
            }
            tower.add(body);

            // Wings (The top part)
            const wingHeight = height - curveStart;
            const wingShape = new THREE.Shape();
            // Draw a profile that looks like one side of the top
            wingShape.moveTo(0,0);
            wingShape.lineTo(width*0.1, 0); // Thickness
            wingShape.lineTo(width*0.1, wingHeight);
            wingShape.bezierCurveTo(width*0.1, wingHeight, 0, wingHeight*0.8, 0, 0); // Inner curve
            
            // Extrude settings
            const extrudeSettings = {
                steps: 10,
                depth: depth,
                bevelEnabled: false
            };
            
            // Left Wing
            // Note: Creating procedural complex curved geometry in vanilla three.js without CSG is tricky.
            // We will approximate the "bottle opener" look with two bent geometric strips.
            
            function createWing(isLeft) {
                const wGeo = new THREE.BoxGeometry(width*0.15, wingHeight, depth);
                // We want to taper/curve it. We'll use a simple rotation for now.
                const wing = new THREE.Mesh(wGeo, glassMaterial);
                
                // Position relative to top of body
                const xOff = (width * 0.4) * (isLeft ? -1 : 1);
                wing.position.set(xOff, bodyH + wingHeight/2, 0);
                
                // Rotate to meet at top? No, they stay parallel but joined by bridge.
                // Actually the real tower curves inward.
                // Let's slant them.
                wing.geometry.translate(0, -wingHeight/2, 0); // Pivot at bottom
                wing.rotation.z = (isLeft ? -1 : 1) * 0.1;
                wing.position.y = bodyH;
                
                return wing;
            }
            
            tower.add(createWing(true));
            tower.add(createWing(false));
            
            // Skybridge
            const bridgeGeo = new THREE.BoxGeometry(width * 0.7, 2, depth * 0.8);
            const bridge = new THREE.Mesh(bridgeGeo, frameMaterial);
            bridge.position.set(0, height - 2, 0);
            bridge.castShadow = true;
            tower.add(bridge);
            
            // Finial / Cap details
            const capGeo = new THREE.BoxGeometry(width*0.9, 1, depth*1.2);
            const cap = new THREE.Mesh(capGeo, frameMaterial);
            cap.position.set(0, bodyH, 0);
            tower.add(cap);

            // Podium
            const podiumGeo = new THREE.CylinderGeometry(width*0.8, width, 4, 32);
            podiumGeo.scale(1, 1, 0.6);
            const podium = new THREE.Mesh(podiumGeo, concreteMaterial);
            podium.position.y = 2;
            podium.receiveShadow = true;
            tower.add(podium);

            return tower;
        }

        const tower = createKingdomTower();
        scene.add(tower);

        // --- Environment Details ---
        
        // Ground Plane
        const planeGeo = new THREE.PlaneGeometry(500, 500);
        const planeMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.6 });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // Simple surrounding blocks
        function addBlock(x, z, h) {
            const geo = new THREE.BoxGeometry(15, h, 15);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, h/2, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Simple windows texture
            const winMat = new THREE.MeshStandardMaterial({color: 0x88ccff});
            // We just add a smaller box slightly protruding
            const winGeo = new THREE.BoxGeometry(15.2, h*0.8, 15.2);
            const win = new THREE.Mesh(winGeo, winMat);
            win.position.set(x, h/2, z);
            
            const group = new THREE.Group();
            group.add(mesh);
            group.add(win);
            scene.add(group);
        }

        addBlock(-40, 40, 30);
        addBlock(40, 40, 40);
        addBlock(-40, -40, 25);
        addBlock(40, -40, 35);


        // --- Labels & Animation ---
        
        const labelBridge = document.getElementById('info-bridge');
        const labelBase = document.getElementById('info-base');
        const vecBridge = new THREE.Vector3(0, SCENE_CONFIG.towerHeight, 0);
        const vecBase = new THREE.Vector3(0, 5, 0);
        const tempV = new THREE.Vector3();

        function updateLabels() {
            updateSingleLabel(vecBridge, labelBridge);
            updateSingleLabel(vecBase, labelBase);
        }

        function updateSingleLabel(position, element) {
            tempV.copy(position);
            tempV.project(camera);
            
            const x = (tempV.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(tempV.y * 0.5) + 0.5) * window.innerHeight;
            
            // Check visibility
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(tempV.x, tempV.y), camera);
            // Simple check: if z > 1 it's behind camera
            if (Math.abs(tempV.z) > 1 || Math.abs(tempV.x) > 1 || Math.abs(tempV.y) > 1) {
                element.style.opacity = 0;
            } else {
                element.style.opacity = 1;
                element.style.transform = `translate(-50%, -100%) translate(${x}px, ${y - 20}px)`;
            }
        }

        // Hide loader
        document.getElementById('loader').style.opacity = 0;
        setTimeout(() => document.getElementById('loader').style.display = 'none', 500);

        // Reflection Map (Environment)
        // To make reflections look good, we generate a PMREM from the scene background
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        scene.environment = pmremGenerator.fromScene(scene).texture;

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateLabels();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
